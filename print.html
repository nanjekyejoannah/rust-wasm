<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./background-and-concepts.html"><strong>2.</strong> Background And Concepts</a></li><li><a href="./setup.html"><strong>3.</strong> Setup</a></li><li><a href="./hello-world.html"><strong>4.</strong> Hello World</a></li><li><a href="./tools.html"><strong>5.</strong> Tools</a></li><li><a href="./workflows.html"><strong>6.</strong> Workflows</a></li><li><a href="./js-ffi.html"><strong>7.</strong> JavaScript Interoperation</a></li><li><a href="./tutorials.html"><strong>8.</strong> Tutorials</a></li><li><ul class="section"><li><a href="./wasm-pack/introduction.html"><strong>8.1.</strong> wasm-pack</a></li><li><ul class="section"><li><a href="./wasm-pack/setup.html"><strong>8.1.1.</strong> Setup</a></li><li><a href="./wasm-pack/initialize.html"><strong>8.1.2.</strong> Project Initialization</a></li><li><a href="./wasm-pack/rust-code.html"><strong>8.1.3.</strong> Rust Code</a></li><li><a href="./wasm-pack/package-code.html"><strong>8.1.4.</strong> Package Code For npm</a></li><li><a href="./wasm-pack/run-the-code.html"><strong>8.1.5.</strong> Run The Code From npm</a></li><li><a href="./wasm-pack/next-steps.html"><strong>8.1.6.</strong> Next Steps</a></li></ul></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <p>This small book describes how to use <a href="https://www.rust-lang.org">Rust</a> and <a href="http://webassembly.org/">WebAssembly</a> together.</p>
<p><a href="https://github.com/rust-lang-nursery/rust-wasm">This book is open source! Find a typo? Did we overlook something? Send us a pull
request!</a></p>
<a class="header" href="print.html#background-and-concepts" id="background-and-concepts"><h1>Background and Concepts</h1></a>
<a class="header" href="print.html#web-assembly" id="web-assembly"><h2>Web Assembly</h2></a>
<p>WebAssembly is a simple machine model and executable format with an <a href="https://webassembly.github.io/spec/">extensive
specification</a>.</p>
<p>Although it has currently gathered attention in the JavaScript and web communities in general,
it makes no assumptions about its host environment. Thus, it makes sense to think that <em>wasm</em>
will become an important &quot;portable executable&quot; format used in a variety of contexts in the near
future (we will dedicate some time to take a closer look at <em>wasm</em>'s portability features further in the book).</p>
<p>As of <em>today</em>, however, <em>wasm</em> is mostly related to JavaScript, which comes in many flavors (including both
browsers and <a href="https://nodejs.org">Node.js</a>). Due to JS being widespread and easy to access we will focus mostly on using these
platforms to run Rust-generated <em>wasm</em>, but other interpreters are probably going to be released in the near future.</p>
<p>As a programming language, WebAssembly is comprised of two formats: The binary format and the text format.
Both represent a common structure, albeit in different ways. The text format (generally called <code>wat</code>) uses
<a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>, which bears some resemblance to languages like Clojure or Racket.
The binary format <code>wasm</code> is a lower level format, being itself the assembly code which is run by the interpreters.</p>
<p>For reference, here is a factorial function in <code>wat</code>:</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    get_local 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      get_local 0
      get_local 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export &quot;fac&quot; (func $fac)))
</code></pre>
<p>If you're curious about how a <code>wasm</code> file looks like you can use <a href="https://cdn.rawgit.com/WebAssembly/wabt/aae5a4b7/demo/wat2wasm/">wat2wasm demo</a> with the above code.</p>
<p>WebAssembly has a very simple <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem">memory model</a>. At the moment, a wasm module has access to a single
&quot;linear memory&quot;, which is essentially a flat array of a fixed
numeric type. This <a href="https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory">memory can be grown</a> by a multiple of the page size (64K),
and cannot be shrunk.</p>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<p>If you want to be able to use Rust for wasm then you need an environment to be able to do that! If
you haven't already you'll need to install <a href="https://www.rustup.rs/">rustup</a> the official tool in order to install
and manage different versions of the Rust compiler. Follow the instructions on the site to get it
installed on your machine. Once that's installed you'll need to get the <code>wasm32-unknown-unknown</code>
toolchain.</p>
<pre><code class="language-bash">$ rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
<p>Next up if you're interested in making small wasm binaries you'll want to
install the <a href="https://github.com/alexcrichton/wasm-gc">wasm-gc</a> tool to make smaller binaries and to work around bugs
in the compiler toolchain for now:</p>
<pre><code>$ cargo install wasm-gc
</code></pre>
<p>And finally if you're <em>really</em> interested in making small wasm binaries you'll
want to install <code>wasm-opt</code> from the <a href="https://github.com/WebAssembly/binaryen">binaryen toolkit</a>.</p>
<a class="header" href="print.html#hello-world-for-wasm32-unknown-unknown" id="hello-world-for-wasm32-unknown-unknown"><h1>&quot;Hello World&quot; for <code>wasm32-unknown-unknown</code></h1></a>
<p>A basic &quot;hello world&quot; can be generated with:</p>
<pre><code>$ cargo +nightly new --lib hello-world
</code></pre>
<p>Next up change <code>Cargo.toml</code> to have:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>and edit <code>src/lib.rs</code> to contain:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern fn add_one(a: u32) -&gt; u32 {
    a + 1
}
#}</code></pre></pre>
<p>Now prepare the wasm binary with:</p>
<pre><code>$ cargo +nightly build --target wasm32-unknown-unknown --release

# make the binary smaller by removing all unneeded exports, imports, and functions 
# (working around bugs in rustc toolchain)
$ wasm-gc target/wasm32-unknown-unknown/release/hello_world.wasm -o hello_world.gc.wasm

# make the binary *even smaller* if you installed `wasm-opt`
$ wasm-opt -Os hello_world.gc.wasm -o hello_world.gc.opt.wasm
</code></pre>
<p>And we can test it out with:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      WebAssembly.instantiateStreaming(fetch('hello_world.gc.opt.wasm'))
        .then(wasm_module =&gt; {
            alert(`2 + 1 = ${wasm_module.instance.exports.add_one(2)}`);
        });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Note: To run with <code>instantiateStreaming</code> and <code>compileStreaming</code>, you need your webserver to serve <code>.wasm</code> file with <code>application/wasm</code> MIME type. The <a href="https://github.com/thecoshman/http">https</a> crate can be used to serve files from <code>localhost</code>, and includes the <code>application/wasm</code> MIME type out of the box.</p>
<p>Alternatively, if you are running locally without any webserver.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      fetch('hello_world.gc.opt.wasm')
        .then(r =&gt; r.arrayBuffer())
        .then(r =&gt; WebAssembly.instantiate(r))
        .then(wasm_module =&gt; {
            alert(`2 + 1 = ${wasm_module.instance.exports.add_one(2)}`);
        });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>If you have Python 3 installed, you can alternatively serve this file with Python's built
in web server from <code>localhost</code>. Python's web server cannot serve <code>instantiateStreaming</code> or
<code>compileStreaming</code> due to its lack of support for the <code>application/wasm</code> MIME type.</p>
<pre><code>$ python3 -m http.server
</code></pre>
<p>Ensure that your browser supports Wasm. Two options:</p>
<ul>
<li>
<p>Run this <a href="https://stackoverflow.com/a/47880734">StackOverflow code snippet</a></p>
</li>
<li>
<p>Search for your browser version's Wasm support on <a href="https://caniuse.com/#search=wasm">caniuse.com</a></p>
</li>
</ul>
<p>Open the HTML file with your browser, you should see:</p>
<p><img src="./images/wasm_hello_world_screenshot.png" alt="Wasm Hello World Screenshot" /></p>
<a class="header" href="print.html#tools" id="tools"><h1>Tools</h1></a>
<p>Now that we've have learned how to generate our first WebAssembly &quot;Hello World&quot; with Rust,
it is time to check out what tooling is available in the language.
There are several great tools already written for WebAssembly (most of them written in C++).
<a href="https://github.com/WebAssembly/wabt">Wabt</a>, for instance, is a suite of tools built to be a starting point for manipulating WebAssembly files.</p>
<p>However, since Rust has the potential to be used for both development and tooling for WebAssembly, several tools written in it have popped up in the ecosystem:</p>
<ul>
<li><a href="https://github.com/alexcrichton/wasm-gc">wasm-gc</a> - a small command to gc a wasm module and remove all unneeded exports, imports, functions, etc.</li>
<li><a href="https://github.com/fitzgen/wasm-nm">wasm-nm</a> - list the symbols within a wasm file.</li>
<li><a href="https://github.com/fitzgen/wasm-snip">wasm-snip</a> - replaces a wasm function body with unreachable</li>
<li><a href="https://github.com/joshuawarner32/rust-wasm">rustwasm</a> - A wasm interpreter in Rust</li>
<li><a href="https://github.com/pepyakin/wasmi">wasmi</a> - Another wasm interpreter in Rust</li>
<li><a href="https://github.com/paritytech/parity-wasm">parity-wasm</a> - wasm (de)serialization in Rust</li>
<li><a href="https://github.com/yurydelendik/wasmparser.rs">wasmparser</a> - A wasm binary decoder with optional validation, in Rust</li>
<li><a href="https://github.com/yurydelendik/wasmtext">wasmtext</a> - prints wasm modules in text format, in Rust</li>
<li><a href="https://github.com/sunfishcode/wasmstandalone">wasmstandalone</a> - standalone JIT-based wasm runner, in Rust, using Cretonne, in early development</li>
<li><a href="https://github.com/ashleygwilliams/wasm-pack">wasm-pack</a> - Package up your wasm for distribution on npm</li>
</ul>
<p>There's also plenty of <em>space for tooling to be be built or rewritten in Rust</em> for better synergy with the ecosystem. Some of them include:</p>
<ul>
<li><a href="https://github.com/rust-lang-nursery/rust-wasm/issues/20">A wasm size profiler</a></li>
<li>A <a href="https://github.com/WebAssembly/wabt">Wabt</a> rewrite in Rust</li>
<li>Tools for the <a href="https://github.com/ewasm">ewasm project</a></li>
</ul>
<p>This page is meant to be a living document, so feel free to send us a pull request adding new incredible WebAssembly tools we might have missed or when they are released in the future!</p>
<a class="header" href="print.html#common-rustwasm-workflows" id="common-rustwasm-workflows"><h1>Common Rust+wasm Workflows</h1></a>
<p>This document is intended to currently collect a number of workflows related to
Rust+wasm over time. Right now it's not necessarily the most organized, but that
may come soon!</p>
<a class="header" href="print.html#javascript-interoperation" id="javascript-interoperation"><h1>JavaScript Interoperation</h1></a>
<a class="header" href="print.html#importing-and-exporting-js-functions" id="importing-and-exporting-js-functions"><h3>Importing and exporting JS functions</h3></a>
<a class="header" href="print.html#from-the-rust-side" id="from-the-rust-side"><h4>From the Rust side</h4></a>
<blockquote>
<p><strong>Note</strong>: this is likely to <a href="https://github.com/rust-lang-nursery/rust-wasm/issues/29">change in the near future</a></p>
</blockquote>
<p>When using wasm within a JS host, importing and exporting functions from the
Rust side is straightforward: it works exactly like C. In particular:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// import a JS function called `foo`
extern { fn foo(); }

// export a Rust function called `bar`
#[no_mangle]
pub extern fn bar() { /* ... */ }
#}</code></pre></pre>
<p>Because of wasm's limited value types, these functions must operate only on
primitive numeric types.</p>
<a class="header" href="print.html#from-the-js-side" id="from-the-js-side"><h4>From the JS side</h4></a>
<p>Within JS, a wasm binary turns into an ES6 module. It must be <em>instantiated</em>
with a linear memory and set of JS functions matching the expected imports. The
details of instantiation are available on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate">MDN</a>.</p>
<p>The resulting ES6 module will contain all of functions exported from Rust, now
available as JS functions.</p>
<p><a href="https://www.hellorust.com/demos/add/index.html">Here</a> is a very simple example of the whole setup in action.</p>
<a class="header" href="print.html#going-beyond-numerics" id="going-beyond-numerics"><h3>Going beyond numerics</h3></a>
<p>When using wasm within JS, there is a sharp split between the wasm module's
memory and the JS memory:</p>
<ul>
<li>
<p>Each wasm module has a linear memory (described at the top of this document),
which is initialized during instantiation. <strong>JS code can freely read and write
to this memory</strong>.</p>
</li>
<li>
<p>By contrast, wasm code has no <em>direct</em> access to JS objects.</p>
</li>
</ul>
<p>Thus, sophisticated interop happens in two main ways:</p>
<ul>
<li>
<p>Copying in or out binary data to the wasm memory. For example, this is one way
to provide an owned <code>String</code> to the Rust side.</p>
</li>
<li>
<p>Setting up an explicit &quot;heap&quot; of JS objects which are then given
&quot;addresses&quot;. This allows wasm code to refer to JS objects indirectly (using
integers), and operate on those objects by invoking imported JS functions.</p>
</li>
</ul>
<p>Fortunately, this interop story is very amenable to treatment through a generic
&quot;bindgen&quot;-style framework: <a href="https://github.com/alexcrichton/wasm-bindgen">wasm-bindgen</a>. The framework makes it possible to
write idiomatic Rust function signatures that map to idiomatic JS functions,
automatically.</p>
<a class="header" href="print.html#tutorials" id="tutorials"><h1>Tutorials</h1></a>
<p>There are a wide variety of tools available in the ecosystem and we want to provide a centralized
way to show you how to get using them more in depth than a basic readme.</p>
<a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p><code>wasm-pack</code> is a brand new tool designed to make packaging up binaries that include wasm (that may
or may not have JS in them) and make publishing them on npm easy to do. We can't necessarily
distribute Rust code to developers directly and expect them
to build it from scratch. npm is used to install packages for frontend work but it doesn't know how
to compile Rust! With wasm though it's not a problem. Once it's compiled it's all good to go.
However, getting it ready to be distributed, packaging it up properly for npm, and then sending it
to npm can be a bit of a hassle. <code>wasm-pack</code> is here to make that easier.</p>
<p>We'll step through creating a simple Rust library, using <code>wasm-pack</code> to get it ready for
distribution, sending it to npm, then using it as a package from npm to verify it works!</p>
<p>As with all software in the early stages this is bleeding edge! Expect some nicks and bruises! If
you run into issues or a bug please file an issue over at it's <a href="https://github.com/ashleygwilliams/wasm-pack/issues">repo</a>.</p>
<a class="header" href="print.html#tools-setup" id="tools-setup"><h1>Tools Setup</h1></a>
<a class="header" href="print.html#rust" id="rust"><h2>Rust</h2></a>
<p>If you haven't already you'll need to install Rust! See <a href="../setup.html">the setup section</a> for more
details. Once you've done that you'll need to install <code>wasm-pack</code>.</p>
<p>Just run the following:</p>
<pre><code class="language-bash">$ cargo install wasm-pack
</code></pre>
<p>and make sure the binary is in your <code>$PATH</code> so you can run it.</p>
<a class="header" href="print.html#npm" id="npm"><h2>npm</h2></a>
<p>If you also have not installed npm already you'll need to do so! Follow the docs available on
<a href="https://www.npmjs.com/get-npm">npm</a> or install it through your package manager!</p>
<p>To confirm you've succeeded run:</p>
<pre><code class="language-bash">$ npm --version
</code></pre>
<p>You should see the version number pop out in your terminal if you installed it successfully!</p>
<a class="header" href="print.html#npm-account" id="npm-account"><h2>npm account</h2></a>
<p>After you have npm installed you'll need to sign up for an account on npm if you have not already
done so in order to complete the tutorial and so you can upload your package. The sign up page can
be found <a href="https://www.npmjs.com/signup">here</a>.</p>
<a class="header" href="print.html#project-initialization" id="project-initialization"><h1>Project Initialization</h1></a>
<p>Now that we've installed all of our tools and setup our npm account we can actually start coding!
We'll be writing up a small crate that adds two numbers and outputs the numbers. While this will
be a simple example, we're really trying to focus on how to use wasm-pack. You'll be provided links
to other resources so you can make more complicated code to package and ship them to npm!</p>
<p>Let's get started then! First off run this command to create our project:</p>
<pre><code class="language-bash">$ cargo new --lib wasm-add
</code></pre>
<p>This will create a new Rust project in a directory called <code>wasm-add</code>. We've also specified that
we're building a library, since we'll be calling this code from JS.</p>
<p>Now just:</p>
<pre><code class="language-bash">$ cd wasm-add
</code></pre>
<p>You'll find everything in here ready to get started. First though we'll need to add a dependency to
our code and make a few small changes. Open up your <code>Cargo.toml</code> file. You should see something like
this inside:</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-add&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Michael Gattozzi &lt;mgattozzi@gmail.com&gt;&quot;]

[dependencies]
</code></pre>
<p>This configuration file sets up everything we need to get started but we'll need a few extra fields
and settings to get this to work for wasm and be ready for npm</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-add&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Michael Gattozzi &lt;mgattozzi@gmail.com&gt;&quot;]
description = &quot;Code used to demonstrate how to use wasm-pack&quot;
license = &quot;MIT/Apache-2.0&quot;
repository = &quot;https://github.com/mgattozzi/wasm-add&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen=&quot;0.2&quot;
</code></pre>
<p>First off lets look at the last three fields added to the package section <code>description</code>, <code>license</code>,
and <code>repository</code> npm requires this metadata and so <code>wasm-pack</code> won't package your code up until you
have them set. There are more fields that you can add that are more specific to <code>crates.io</code> that you
can find <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">here</a> but for the sake of this
tutorial that's all you need for that section.</p>
<p>You'll also notice we add a new section titled <code>[lib]</code>. In here we added this line:</p>
<pre><code class="language-toml">crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>Normally rust compiles the code for the library in a format meant for other Rust packages. We want
our code to work with wasm though! We specify that it's a dynamic library that's C compatible. This
sounds a bit weird but the <code>wasm32</code> target will know to interpret this option and instead produce
a wasm binary properly. This is meant to get <code>cargo</code> to pass the right parameters to the compiler!</p>
<p>Alright the last thing we added was this to the <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">wasm-bindgen=&quot;0.2&quot;
</code></pre>
<p>This is the <code>wasm-bindgen</code> crate. We'll be using it very shortly to make our functions work nicely
with wasm and not have to worry about a lot of nitty gritty details.</p>
<p>We've got our package's metadata all setup so let's actually write some code!</p>
<a class="header" href="print.html#rust-code" id="rust-code"><h1>Rust Code</h1></a>
<p>If you open up <code>src/lib.rs</code> you should see a file that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Let's quickly modify the test suite to work for what we'll be doing. It should look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(add(2, 2), 4);
}
#}</code></pre></pre>
<p>We'll use this later to make sure our <code>add</code> function works!</p>
<p>Now we need to add this to the top of the file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(proc_macro, wasm_import_module, wasm_custom_section)]
#fn main() {
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;
#}</code></pre></pre>
<p>Let's step through this line by line. First up is the list of nightly features. We're enabling this for
the whole crate. What this means is that we will later tag code with an attribute and this will
allow rust to generate code that we don't have to write by hand. In our case it'll use
<code>wasm-bindgen.</code> It should be noted that <code>#![feature(...)]</code> implies using the nightly
compiler. This gated feature will hopefully be stabilized and landed soon so that you won't need it!</p>
<p><code>wasm-bindgen</code> knows how to make code that works well with wasm so we don't have to
worry about it too much and just write rust code for the most part. If you want to know the full
extent of it's capabilities check out the README on it's repo which can be found
<a href="https://github.com/alexcrichton/wasm-bindgen">here</a>. For our purposes we need to know that if we
want functions to work with wasm easily we'll need it.</p>
<p>The next line says we're importing the <code>wasm-bindgen</code> crate and the line after that imports the
prelude from <code>wasm-bindgen</code>. The <code>extern crate</code> call lets the compiler know what crates to link in
and the <code>prelude</code> contains all the types and functions that <code>wasm-bindgen</code> needs to work properly!</p>
<p>Cool let's import the <code>alert</code> function from JS so that we can call it in our Rust code!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}
#}</code></pre></pre>
<p>First off we use the <code>#[wasm_bindgen]</code> attribute. This attribute will handle all the code with
importing the functions we declare below it. The next is an extern block. This lets us declare
what JS functions we want to import. We just need to declare the function signature for it. In this
case we're importing the function <code>alert</code> which takes an <code>&amp;str</code> as input!</p>
<p>Alright so we have our external bit of code and we have everything imported so let's write the
actual <code>add</code> function, as well as an <code>add_alert</code> function that will use <code>add</code> in itself but also
call <code>alert</code> to print out the results before returning the value.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[wasm_bindgen]
pub fn alert_add(a: i32, b: i32) -&gt; i32 {
    let c = add(a, b);
    alert(&amp;format!(&quot;Hello from Rust! {} + {} = {}&quot;, a, b, c));
    c
}
#}</code></pre></pre>
<p>You'll notice that both functions have this <code>#[no_mangle]</code> attribute. When we export functions in
Rust to other languages we need to make sure the name doesn't get changed when compiled so that if
we want to call <code>add</code> that it will be called <code>add</code> and not a random compiler generated name. Now
we've also said that these are both <code>pub extern fn</code> by putting the <code>extern</code> keyword in there we
have marked this as a function that can be called by another language outside of Rust. You can also
call these functions inside of Rust as we can see inside <code>alert_add</code>.</p>
<p>The rest is fairly straightforward if you're familiar with Rust, but if you're not we'll walk
through it. Both functions take a value <code>a</code> and a value <code>b</code>. We have said that both are 32 bit
integers (i32). We then say both will return an i32. The last line in a function returns the value
if there is no semicolon. So in the <code>add</code> function the value of <code>a + b</code> gets calculated and it's
value is returned! In the case of <code>alert_add</code> we store the value of the <code>add</code> function we just made
into the variable <code>c</code>. We then call <code>alert</code> saying what the add operation looked like and what the
value was! We then return what was inside <code>c</code>. Neat!</p>
<p>This is all the Rust code we need to write. Your <code>lib.rs</code> file should look like this by now:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(proc_macro, wasm_import_module, wasm_custom_section)]
#fn main() {
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[wasm_bindgen]
pub fn alert_add(a: i32, b: i32) -&gt; i32 {
    let c = add(a, b);
    alert(&amp;format!(&quot;Hello from Rust! {} + {} = {}&quot;, a, b, c));
    c
}

#[test]
fn it_works() {
    assert_eq!(add(2, 2), 4);
}
#}</code></pre></pre>
<p>Just to make sure that <code>add</code> works we'll run the test we wrote earlier:</p>
<pre><code class="language-bash">$ cargo test
</code></pre>
<p>You should get output that looks sort of like this:</p>
<pre><code class="language-bash">   Compiling wasm-add v0.1.1 (file:///home/michael/Code/wasm-add)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54 secs
     Running target/debug/deps/wasm_add-5d5676e23e39dbea
running 1 test
test it_works ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Yay it all works! Notice we didn't add a test for <code>alert_add</code>. This is because Rust won't know what
<code>alert</code> is unless the wasm code is running in the browser! Don't worry though. Once we package this
code up and upload it to npm we'll then test out that function to make sure everything works like we
expect it too!</p>
<p>You can find all of the above code <a href="https://github.com/mgattozzi/wasm-add">here</a>.</p>
<a class="header" href="print.html#package-code-for-npm" id="package-code-for-npm"><h1>Package Code for npm</h1></a>
<p>We've made our code so now we need to package it all up. In your project directory run the following
command:</p>
<pre><code class="language-bash">$ wasm-pack init --scope MYSCOPE
</code></pre>
<p>where <code>MYSCOPE</code> is your name or something. Normally you could just type <code>wasm-pack init</code> but since
other people are doing this tutorial as well we don't want conflicts with the <code>wasm-add</code> package
name! This command when run does a few things:</p>
<ol>
<li>It'll compile your code to wasm if you haven't already</li>
<li>It'll generate a pkg folder with the wasm file, a JS wrapper file around the wasm, your README,
and a <code>package.json</code> file.</li>
</ol>
<p>This is everything you need to upload your code to npm! Let's do just that!</p>
<p>First off you'll need to login to npm with the account you made earlier if you didn't already have
one:</p>
<pre><code class="language-bash">$ npm login
</code></pre>
<p>Next you'll need to go into the <code>pkg</code> directory and actually upload the package:</p>
<pre><code class="language-bash">$ cd pkg
$ npm publish --access=public
</code></pre>
<p>Now normally if things are not scoped you can just do <code>npm publish</code> but if you give it a scope
you'll need to tell npm that this is actually public so it can publish it. We need to do that here
since we gave our packages a scope to avoid conflicting with each other! Next up is actually running
the code and verifying we got it from npm and how we can use that code.</p>
<a class="header" href="print.html#run-the-code-from-npm" id="run-the-code-from-npm"><h1>Run The Code From npm</h1></a>
<p>Alright let's make a new small directory to test that we can now run this code and pull it from npm.</p>
<pre><code class="language-bash">$ mkdir test
$ cd test
</code></pre>
<p>Now we need to create a <code>package.json</code> file that looks like this:</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@MYSCOPE/wasm-add&quot;: &quot;^0.1.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.0.1&quot;,
    &quot;webpack-cli&quot;: &quot;^2.0.10&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.0&quot;
  }
}
</code></pre>
<p>where <code>MYSCOPE</code> is whatever you used before. You can expand this to be a more complete file but
we're really just trying to verify that this works!</p>
<p>Next up we'll need to create a small webpack configuration so that we can use the
<code>webpack-dev-server</code> to serve the wasm file properly. It should be noted that webpack isn't
a requirement. It's just what was chosen for this tutorial. You just need something to server the
code! Here's what it should look like:</p>
<pre><code class="language-javascript">const path = require('path');
module.exports = {
  entry: &quot;./index.js&quot;,
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;index.js&quot;,
  },
  mode: &quot;development&quot;
};
</code></pre>
<p>This tells webpack that if it's going to start things up use <code>index.js</code>. Before we do that though
we'll need to setup a small html file. Create a new file called <code>index.html</code> and put this inside it:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;meta content=&quot;text/html;charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src='./index.js'&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>We're almost set. Now we need to setup our JS file so that we can run some wasm code!
Make a file called <code>index.js</code> and put this inside of it:</p>
<pre><code class="language-javascript">const js = import(&quot;./node_modules/@MYSCOPE/wasm-add/wasm_add.js&quot;);
js.then(js =&gt; {
  js.alert_add(3,2);
});
</code></pre>
<p>Since web pack <a href="https://github.com/webpack/webpack/issues/6615">can't load wasm synchronously yet</a>
we are using the import statement above followed
by the promise in order to load it properly. This is what lets us then call <code>alert_add</code>. We're
importing from the <code>node_module</code> folder we haven't gotten yet so let's import all of our
dependencies finally and run the example!</p>
<pre><code class="language-bash">$ npm install
$ npm run serve
</code></pre>
<p>Then in a web browser navigate to <code>http://localhost:8080</code> you should see something like this:</p>
<p><img src="/wasm-pack/wasm-pack.png" alt="An alert box saying &quot;Hello from Rust! 3 + 2 = 5&quot;" /></p>
<p>If you did congrats you've successfully uploaded your first bit of wasm code to npm and used it
properly!</p>
<a class="header" href="print.html#next-steps" id="next-steps"><h1>Next Steps</h1></a>
<p>This was an introduction to wasm-pack but also using wasm code from npm. From here you could
actually improve on the project setup, expand out what your wasm code can actually do, or expand out
how you would use the package you've created. The whole wasm space is completely open so there's no
limit to what you can and can't do really! Go out there and try some cool new things. Happy hacking!</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
